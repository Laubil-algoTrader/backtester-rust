//+------------------------------------------------------------------+
//|                                            BT_ParabolicSAR.mq5    |
//|              Custom indicator — Generated by Backtester Rust      |
//|   Replicates exact Parabolic SAR from backtester engine.          |
//+------------------------------------------------------------------+
#property copyright "Generated by Backtester Rust"
#property version   "1.00"
#property strict
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_label1  "SAR"
#property indicator_type1   DRAW_ARROW
#property indicator_color1  clrMagenta
#property indicator_width1  1

input double InpAF  = 0.02; // Acceleration Factor
input double InpMax = 0.20; // Maximum AF

double SarBuffer[];

int OnInit()
{
   SetIndexBuffer(0, SarBuffer, INDICATOR_DATA);
   PlotIndexSetInteger(0, PLOT_ARROW, 159); // small dot
   PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, EMPTY_VALUE);
   IndicatorSetString(INDICATOR_SHORTNAME,
      "BT_SAR(" + DoubleToString(InpAF, 2) + "," + DoubleToString(InpMax, 2) + ")");
   return INIT_SUCCEEDED;
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(rates_total < 2) return 0;

   // Full recalc — Parabolic SAR is path-dependent
   if(prev_calculated == 0)
   {
      bool isLong = (high[1] > high[0]);
      double af  = InpAF;
      double ep  = isLong ? high[0] : low[0];
      double sar = isLong ? low[0]  : high[0];

      SarBuffer[0] = sar;

      for(int i = 1; i < rates_total; i++)
      {
         double prevSar = sar;
         sar = prevSar + af * (ep - prevSar);

         if(isLong)
         {
            // SAR must not be above the two previous lows
            if(i >= 2)
               sar = MathMin(sar, MathMin(low[i - 1], low[i - 2]));
            else
               sar = MathMin(sar, low[i - 1]);

            // Check for reversal
            if(low[i] < sar)
            {
               isLong = false;
               sar = ep;
               ep = low[i];
               af = InpAF;
            }
            else
            {
               if(high[i] > ep)
               {
                  ep = high[i];
                  af = MathMin(af + InpAF, InpMax);
               }
            }
         }
         else
         {
            // SAR must not be below the two previous highs
            if(i >= 2)
               sar = MathMax(sar, MathMax(high[i - 1], high[i - 2]));
            else
               sar = MathMax(sar, high[i - 1]);

            // Check for reversal
            if(high[i] > sar)
            {
               isLong = true;
               sar = ep;
               ep = high[i];
               af = InpAF;
            }
            else
            {
               if(low[i] < ep)
               {
                  ep = low[i];
                  af = MathMin(af + InpAF, InpMax);
               }
            }
         }

         SarBuffer[i] = sar;
      }
   }
   else
   {
      // SAR is path-dependent, force full recalc
      return 0;
   }

   return rates_total;
}
