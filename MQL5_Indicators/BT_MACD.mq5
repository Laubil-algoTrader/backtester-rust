//+------------------------------------------------------------------+
//|                                                     BT_MACD.mq5  |
//|              Custom indicator â€” Generated by Backtester Rust      |
//|   Replicates exact MACD calculation from backtester engine.       |
//|   Uses SMA-seeded EMA for fast/slow lines and signal.             |
//|   Buffer 0: MACD line, Buffer 1: Signal, Buffer 2: Histogram     |
//+------------------------------------------------------------------+
#property copyright "Generated by Backtester Rust"
#property version   "1.00"
#property strict
#property indicator_separate_window
#property indicator_buffers 5
#property indicator_plots   3
#property indicator_label1  "MACD"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDodgerBlue
#property indicator_width1  1
#property indicator_label2  "Signal"
#property indicator_type2   DRAW_LINE
#property indicator_color2  clrRed
#property indicator_width2  1
#property indicator_label3  "Histogram"
#property indicator_type3   DRAW_HISTOGRAM
#property indicator_color3  clrGray
#property indicator_width3  2

input int InpFastPeriod   = 12; // Fast EMA Period
input int InpSlowPeriod   = 26; // Slow EMA Period
input int InpSignalPeriod = 9;  // Signal EMA Period

double MacdBuffer[];
double SignalBuffer[];
double HistBuffer[];
double FastEmaBuffer[];
double SlowEmaBuffer[];

int OnInit()
{
   SetIndexBuffer(0, MacdBuffer, INDICATOR_DATA);
   SetIndexBuffer(1, SignalBuffer, INDICATOR_DATA);
   SetIndexBuffer(2, HistBuffer, INDICATOR_DATA);
   SetIndexBuffer(3, FastEmaBuffer, INDICATOR_CALCULATIONS);
   SetIndexBuffer(4, SlowEmaBuffer, INDICATOR_CALCULATIONS);
   PlotIndexSetInteger(0, PLOT_DRAW_BEGIN, InpSlowPeriod);
   PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, EMPTY_VALUE);
   PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, EMPTY_VALUE);
   PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, EMPTY_VALUE);
   IndicatorSetString(INDICATOR_SHORTNAME,
      "BT_MACD(" + IntegerToString(InpFastPeriod) + "," +
      IntegerToString(InpSlowPeriod) + "," + IntegerToString(InpSignalPeriod) + ")");
   return INIT_SUCCEEDED;
}

// Helper: compute EMA buffer (SMA-seeded, same as Rust engine)
void ComputeEMA(const double &src[], double &dst[], int period, int rates_total, int prev_calculated)
{
   double mult = 2.0 / (period + 1.0);
   int start;
   if(prev_calculated == 0)
   {
      for(int i = 0; i < period - 1; i++)
         dst[i] = EMPTY_VALUE;
      double sum = 0;
      for(int i = 0; i < period; i++)
         sum += src[i];
      dst[period - 1] = sum / period;
      start = period;
   }
   else
   {
      start = prev_calculated - 1;
   }
   for(int i = start; i < rates_total; i++)
      dst[i] = (src[i] - dst[i - 1]) * mult + dst[i - 1];
}

// Helper: EMA on a buffer that may contain EMPTY_VALUE
void ComputeEMAOnSlice(const double &src[], double &dst[], int period, int rates_total, int prev_calculated)
{
   double mult = 2.0 / (period + 1.0);
   if(prev_calculated == 0)
   {
      // Find first window of 'period' consecutive valid values
      int seedStart = -1;
      for(int i = 0; i <= rates_total - period; i++)
      {
         bool allValid = true;
         for(int j = i; j < i + period; j++)
         {
            if(src[j] == EMPTY_VALUE) { allValid = false; break; }
         }
         if(allValid) { seedStart = i; break; }
      }
      if(seedStart < 0) { ArrayInitialize(dst, EMPTY_VALUE); return; }

      for(int i = 0; i < seedStart + period - 1; i++)
         dst[i] = EMPTY_VALUE;

      double sum = 0;
      for(int i = seedStart; i < seedStart + period; i++)
         sum += src[i];
      dst[seedStart + period - 1] = sum / period;

      for(int i = seedStart + period; i < rates_total; i++)
      {
         if(src[i] == EMPTY_VALUE) { dst[i] = dst[i - 1]; continue; }
         dst[i] = (src[i] - dst[i - 1]) * mult + dst[i - 1];
      }
   }
   else
   {
      int start = prev_calculated - 1;
      for(int i = start; i < rates_total; i++)
      {
         if(src[i] == EMPTY_VALUE) { dst[i] = dst[i - 1]; continue; }
         dst[i] = (src[i] - dst[i - 1]) * mult + dst[i - 1];
      }
   }
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(rates_total < InpSlowPeriod) return 0;

   // Fast & slow EMA on close
   ComputeEMA(close, FastEmaBuffer, InpFastPeriod, rates_total, prev_calculated);
   ComputeEMA(close, SlowEmaBuffer, InpSlowPeriod, rates_total, prev_calculated);

   // MACD line = fast - slow
   int start = (prev_calculated == 0) ? 0 : prev_calculated - 1;
   for(int i = start; i < rates_total; i++)
   {
      if(FastEmaBuffer[i] == EMPTY_VALUE || SlowEmaBuffer[i] == EMPTY_VALUE)
         MacdBuffer[i] = EMPTY_VALUE;
      else
         MacdBuffer[i] = FastEmaBuffer[i] - SlowEmaBuffer[i];
   }

   // Signal line = EMA of MACD line
   ComputeEMAOnSlice(MacdBuffer, SignalBuffer, InpSignalPeriod, rates_total, prev_calculated);

   // Histogram = MACD - Signal
   for(int i = start; i < rates_total; i++)
   {
      if(MacdBuffer[i] == EMPTY_VALUE || SignalBuffer[i] == EMPTY_VALUE)
         HistBuffer[i] = EMPTY_VALUE;
      else
         HistBuffer[i] = MacdBuffer[i] - SignalBuffer[i];
   }

   return rates_total;
}
