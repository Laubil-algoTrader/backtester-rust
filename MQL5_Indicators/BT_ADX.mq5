//+------------------------------------------------------------------+
//|                                                      BT_ADX.mq5  |
//|              Custom indicator â€” Generated by Backtester Rust      |
//|   Replicates exact ADX calculation from backtester engine.        |
//|   Uses Wilder's smoothing for TR, +DM, -DM, and ADX.             |
//+------------------------------------------------------------------+
#property copyright "Generated by Backtester Rust"
#property version   "1.00"
#property strict
#property indicator_separate_window
#property indicator_buffers 1
#property indicator_plots   1
#property indicator_label1  "ADX"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDodgerBlue
#property indicator_width1  1
#property indicator_level1  25

input int InpPeriod = 14; // Period

double AdxBuffer[];

// Internal state for Wilder's smoothing
double gSmoothTR  = 0;
double gSmoothPDM = 0;
double gSmoothMDM = 0;
double gAdx       = 0;
bool   gSmoothed  = false;
bool   gAdxSeeded = false;
int    gDxCount   = 0;
double gDxSum     = 0;

int OnInit()
{
   SetIndexBuffer(0, AdxBuffer, INDICATOR_DATA);
   PlotIndexSetInteger(0, PLOT_DRAW_BEGIN, InpPeriod * 2);
   PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, EMPTY_VALUE);
   IndicatorSetString(INDICATOR_SHORTNAME, "BT_ADX(" + IntegerToString(InpPeriod) + ")");
   return INIT_SUCCEEDED;
}

int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if(rates_total < InpPeriod * 2 + 1) return 0;

   if(prev_calculated == 0)
   {
      ArrayInitialize(AdxBuffer, EMPTY_VALUE);

      // Initialize: sum first 'period' TR, +DM, -DM (indices 1..period)
      gSmoothTR  = 0;
      gSmoothPDM = 0;
      gSmoothMDM = 0;
      for(int i = 1; i <= InpPeriod; i++)
      {
         double hl = high[i] - low[i];
         double hc = MathAbs(high[i] - close[i - 1]);
         double lc = MathAbs(low[i] - close[i - 1]);
         gSmoothTR += MathMax(hl, MathMax(hc, lc));

         double upMove   = high[i] - high[i - 1];
         double downMove = low[i - 1] - low[i];
         gSmoothPDM += (upMove > downMove && upMove > 0) ? upMove : 0;
         gSmoothMDM += (downMove > upMove && downMove > 0) ? downMove : 0;
      }
      gSmoothed = true;

      // Compute DX for indices period..2*period-1 and accumulate for ADX seed
      gDxSum   = 0;
      gDxCount = 0;

      // First DX at index=period
      {
         double pdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothPDM / gSmoothTR;
         double mdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothMDM / gSmoothTR;
         double diSum = pdi + mdi;
         double dx = (diSum == 0) ? 0 : 100.0 * MathAbs(pdi - mdi) / diSum;
         gDxSum += dx;
         gDxCount++;
      }

      // Continue Wilder's smoothing and accumulate DX
      for(int i = InpPeriod + 1; i < InpPeriod * 2; i++)
      {
         double hl = high[i] - low[i];
         double hc = MathAbs(high[i] - close[i - 1]);
         double lc = MathAbs(low[i] - close[i - 1]);
         double tr = MathMax(hl, MathMax(hc, lc));

         double upMove   = high[i] - high[i - 1];
         double downMove = low[i - 1] - low[i];
         double pdm = (upMove > downMove && upMove > 0) ? upMove : 0;
         double mdm = (downMove > upMove && downMove > 0) ? downMove : 0;

         gSmoothTR  = gSmoothTR  - gSmoothTR  / InpPeriod + tr;
         gSmoothPDM = gSmoothPDM - gSmoothPDM / InpPeriod + pdm;
         gSmoothMDM = gSmoothMDM - gSmoothMDM / InpPeriod + mdm;

         double pdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothPDM / gSmoothTR;
         double mdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothMDM / gSmoothTR;
         double diSum = pdi + mdi;
         double dx = (diSum == 0) ? 0 : 100.0 * MathAbs(pdi - mdi) / diSum;
         gDxSum += dx;
         gDxCount++;
      }

      // ADX seed = average of first 'period' DX values at index 2*period - 1
      {
         int i = InpPeriod * 2 - 1;
         double hl = high[i] - low[i];
         double hc = MathAbs(high[i] - close[i - 1]);
         double lc = MathAbs(low[i] - close[i - 1]);
         double tr = MathMax(hl, MathMax(hc, lc));

         double upMove   = high[i] - high[i - 1];
         double downMove = low[i - 1] - low[i];
         double pdm = (upMove > downMove && upMove > 0) ? upMove : 0;
         double mdm = (downMove > upMove && downMove > 0) ? downMove : 0;

         gSmoothTR  = gSmoothTR  - gSmoothTR  / InpPeriod + tr;
         gSmoothPDM = gSmoothPDM - gSmoothPDM / InpPeriod + pdm;
         gSmoothMDM = gSmoothMDM - gSmoothMDM / InpPeriod + mdm;

         double pdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothPDM / gSmoothTR;
         double mdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothMDM / gSmoothTR;
         double diSum = pdi + mdi;
         double dx = (diSum == 0) ? 0 : 100.0 * MathAbs(pdi - mdi) / diSum;
         gDxSum += dx;
         gDxCount++;

         gAdx = gDxSum / gDxCount;
         AdxBuffer[i] = gAdx;
         gAdxSeeded = true;
      }

      // Continue from 2*period onwards
      for(int i = InpPeriod * 2; i < rates_total; i++)
      {
         double hl = high[i] - low[i];
         double hc = MathAbs(high[i] - close[i - 1]);
         double lc = MathAbs(low[i] - close[i - 1]);
         double tr = MathMax(hl, MathMax(hc, lc));

         double upMove   = high[i] - high[i - 1];
         double downMove = low[i - 1] - low[i];
         double pdm = (upMove > downMove && upMove > 0) ? upMove : 0;
         double mdm = (downMove > upMove && downMove > 0) ? downMove : 0;

         gSmoothTR  = gSmoothTR  - gSmoothTR  / InpPeriod + tr;
         gSmoothPDM = gSmoothPDM - gSmoothPDM / InpPeriod + pdm;
         gSmoothMDM = gSmoothMDM - gSmoothMDM / InpPeriod + mdm;

         double pdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothPDM / gSmoothTR;
         double mdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothMDM / gSmoothTR;
         double diSum = pdi + mdi;
         double dx = (diSum == 0) ? 0 : 100.0 * MathAbs(pdi - mdi) / diSum;

         gAdx = (gAdx * (InpPeriod - 1) + dx) / InpPeriod;
         AdxBuffer[i] = gAdx;
      }
   }
   else
   {
      int start = prev_calculated - 1;
      for(int i = start; i < rates_total; i++)
      {
         double hl = high[i] - low[i];
         double hc = MathAbs(high[i] - close[i - 1]);
         double lc = MathAbs(low[i] - close[i - 1]);
         double tr = MathMax(hl, MathMax(hc, lc));

         double upMove   = high[i] - high[i - 1];
         double downMove = low[i - 1] - low[i];
         double pdm = (upMove > downMove && upMove > 0) ? upMove : 0;
         double mdm = (downMove > upMove && downMove > 0) ? downMove : 0;

         gSmoothTR  = gSmoothTR  - gSmoothTR  / InpPeriod + tr;
         gSmoothPDM = gSmoothPDM - gSmoothPDM / InpPeriod + pdm;
         gSmoothMDM = gSmoothMDM - gSmoothMDM / InpPeriod + mdm;

         double pdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothPDM / gSmoothTR;
         double mdi = (gSmoothTR == 0) ? 0 : 100.0 * gSmoothMDM / gSmoothTR;
         double diSum = pdi + mdi;
         double dx = (diSum == 0) ? 0 : 100.0 * MathAbs(pdi - mdi) / diSum;

         gAdx = (gAdx * (InpPeriod - 1) + dx) / InpPeriod;
         AdxBuffer[i] = gAdx;
      }
   }

   return rates_total;
}
